---
layout: default
title: 20230629
parent: Today I Learned
---

# Today list : 테이블 구조 2차 수정

### 테이블 데이터 타입

**DATETIME과 TIMESTAMP**

- **DATETIME**

  - 특정 일시를 저장한다. 이때 시간대는 고려하지 않는다.
  - 서버의 시간대가 변경되어도 DATETIME 필드의 값은 변하지 않는다.
  - 이 타입은 '1000-01-01 00:00:00'부터 '9999-12-31 23:59:59'까지의 값을 가질 수 있다.

- **TIMESTAMP**

  - 특정 일시를 저장한다.

  - 이때의 시간은 유닉스 타임스탬프(1970년 1월 1일 이후의 초 단위 시간)로 변환된다.

  - 이로 인해 TIMESTAMP는 서버의 시간대 설정에 따라 변할 수 있다.

  - `TIMESTAMP`는 '1970-01-01 00:00:01' UTC에서 '2038-01-19 03:14:07' UTC까지의 값을 가질 수 있다.

  - **<u>시나리오</u>**

    ```
    애플리케이션의 데이터베이스 서버는 미국 캘리포니아에 위치해 있고, 서버의 시간대 설정은 패시픽 표준시간(PST, UTC-8)입니다.
    한 사용자가 한국에서 데이터를 생성하고, 이 때의 한국 시간은 오후 6시입니다. 한국 시간은 한국 표준시(KST, UTC+9)입니다.
    이 사용자가 생성한 데이터의 TIMESTAMP 필드는 한국 시간을 UTC로 변환한 값, 즉 오전 9시를 저장합니다.
    그런데 이 데이터를 데이터베이스 서버에서 조회하면, TIMESTAMP 필드는 서버의 시간대 설정에 따라 패시픽 표준시간으로 변환된 값, 즉 이전날 오후 1시를 보여줍니다.
    ```

**id 필드는 왜 int로 하는게 일반적일까?**

- `AUTO_INCREMENT` 속성을 사용하면, 각 행에 대해 고유한 `id` 값을 자동으로 생성 가능
- <u>**`INT` 또는 `BIGINT` 타입의 `id` 필드는 인덱싱에 최적화**</u>되어 있음.
- `id` 필드는 간결하며, 다른 테이블에서 참조할 때도 이해하기 쉽다.

**email 필드 길이는 255**

- RFC 4321에서 이메일 주소 로컬 부분과 도메인 부분의 함을 최대 254자로 제한하고 있기때문에, 255로 설정하면 모든 이메일 주소를 저장할 수 있다.
  - [관련 문서](https://datatracker.ietf.org/doc/html/rfc5321#section-4.5.3.1.3)

**password 는 해싱을 한다는 전제하에 64 글자면 충분할 것 같다.**

해시 알고리즘 별 특징

1. **MD5**: MD5 해시는 주로 레거시(legacy) 시스템에서 사용됩니다. MD5 해시는 32글자의 16진수로 출력됩니다. 그러나 MD5는 이미 여러 가지 공격에 취약하다고 알려져 있으므로, 새로운 시스템에서는 사용을 피하는 것이 좋습니다.
2. **SHA-1**: SHA-1 해시는 MD5와 마찬가지로 레거시 시스템에서 주로 사용됩니다. SHA-1 해시는 40글자의 16진수로 출력됩니다. 그러나 SHA-1 역시 이미 여러 가지 공격에 취약하다고 알려져 있으므로, 새로운 시스템에서는 사용을 피하는 것이 좋습니다.
3. **SHA-256**: SHA-256 해시는 SHA-2 해시 함수 패밀리에 속하며, 현재 널리 사용되고 있습니다. SHA-256 해시는 64글자의 16진수로 출력됩니다.
4. **bcrypt**: bcrypt는 비밀번호 저장을 위해 설계된 특수한 해시 함수입니다. bcrypt는 사용자가 해시의 "강도"를 설정할 수 있도록 해, 컴퓨터 성능이 향상되더라도 비밀번호를 안전하게 유지할 수 있습니다. bcrypt 해시는 60글자로 출력됩니다.
5. **scrypt**: scrypt도 bcrypt와 같이 비밀번호 저장을 위해 설계된 특수한 해시 함수입니다. scrypt는 메모리를 많이 사용하여 더 복잡한 공격을 방지하는 특징이 있습니다.
6. **Argon2**: Argon2는 비밀번호 해싱을 위한 상대적으로 최신의 알고리즘이며, 2015년 비밀번호 해싱 경쟁에서 우승했습니다. 메모리 사용량, 시간 요구량, 병렬 처리 요구량 등을 사용자가 설정할 수 있습니다.

### 테이블 생성. `SQL 쿼리문으로` or `nodejs에 생성 쿼리로`?

- SQL쿼리를 직접 작성하여 데이터베이스에서 실행
  - GUI로 도 사용 가능
  - SQL에 대해 잘 알아야 함.
- ORM을 통한 자동 생성
  - 쿼리를 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있음.
  - 코드의 가독성을 높일고 중복을 줄여줌
  - 마이그레이션 기능을 사용하면 코드를 통해 데이터베이스 스키마 버전을 관리 가능
  - ORM 자체의 학습 곡선이 있음.
  - ORM의 제한 때문에 복잡한 쿼리를 작성하는 데 어려움을 겪을 수 있음.

일반적으로, 개발 초기 단계에서는 ORM을 사용하여 빠르게 프로토타입을 만들고, 성능 최적화나 복잡한 쿼리가 필요할 때는 SQL을 직접 작성하는 것이 효과적일 수 있다.
