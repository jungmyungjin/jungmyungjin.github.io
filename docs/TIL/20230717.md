---
layout: default
title: 20230717
parent: Today I Learned

---

## 💃🏼 TodayList : Front
### 리액트 폴더구조
*개발팀이나 프로젝트에 따라 사용되는 구조가 다르지만, 일반적으로 사용되는 몇가지 방식들*

#### 1. `기능` 기반(Feature-based) 폴더 구조
- 특정 기능에 따라 폴더를 나누는 방식.

```
/src
 /components
 /features
     /Auth
         /components
         /services
         /tests
     /Dashboard
         /components
         /services
         /tests
 /services
 /styles
 /utils

```

- **장점**
	- 기능 별로 코드를 모아두면 관련된 코드를 찾기 쉽다.
	- 기능이 분리되어 있으므로, 한 기능에 대한 수정이 다른 기능에 영향을 미치는 것을 최소화 할 수 있다.
	- 기능 단위로 코드를 분리하면 재사용성이 높아질 수 있다.
- **단점**
	- 어떤 기능이 다른 기능과 강하게 결합되어 있는 경우, 여러 폴더에서 코드를 작업해야 하는 상황이 발생할 수 있다.
	- 코드가 여러 폴더에 분산되어 있어서, 특정 기능과 관련된 모든 코드를 찾기 어렵거나 시간이 걸릴 수 있다.




#### 2. `File Type` 기반 폴더 구조
- 파일의 타입에 따라 폴더를 구성하는 방식
- 예를 들어, 모든 컴포넌트는 components 폴더에, 모든 서비스는 services 폴더에, 모든 테스트는 tests 폴더에 들어가는 식이다.

```
/src
 /components
     /Button
     /Header
     /Footer
 /services
     /authService
     /dataService
 /tests
     /Button.test
     /Header.test
     /Footer.test
 /styles
 /utils
```

- **장점**
	- 특정 타입의 파일을 찾기 쉽다.
		- 예를 들면 모든 컴포넌트는 한 폴더에 모여 있으므로 빠르게 찾을 수 있다.
	- 구조가 단순하고 직관적이어서 새로운 개발자가 빠르게 이해할 수 있다
- **단점**
	- 관련된 파일들이 여러 폴더에 걸쳐서 분산되어 있을 수 있어, 연관된 코드를 한번에 볼 수 없는 경우가 생긴다.
		- 예를 들어, 하나의 기능을 수정하기 위해 컴포넌트, 서비스, 스타일 각각의 폴더를 방문해야 할 수 있다.
	- 큰 프로젝트에서는 특정 타입의 파일이 많아지면 해당 폴더가 매우 커질 수 있다.


#### 3. `모듈` 기반 폴더 구조
- 각 모듈에 대한 폴더를 만드는 방식
- 예를 들어, 사용자 인증, 데이터 처리 등의 모듈별로 폴더를 생성하고 그 안에는 모듈 관련 파일들이 모두 들어간다

```
/src
 /modules
     /auth
         /components
         /services
         /tests
     /data
         /components
         /services
         /tests
 /components
 /styles
 /utils
```

- **장점**
	- 기능 기반 폴더구조와 유사하게, 모듈별로 코드를 모아두면 관련된 코드를 찾기 쉽다
	- 각 모듈이 독립적이므로, 한 모듈에 대한 변경이 다른 모듈에 영향을 미치는 것을 최소화 할 수 있다
- **단점**
	- 어떤 모듈이 다른 모듈과 강하게 결합되어 있는 경우, 여러 폴더에서 코드를 작업해야 하는 상황이 발생할 수 있다.
	- 특정 모듈에 대한 이해 없이는 해당 코드를 파악하기 어려울 수 있다.




### 🐑 components/[컴포넌트 명]/[파일명] 에서 파일명을 `index.js`  로 할까? 일반 파일명으로 할 지 고민...
#### `index.js` 를 사용하는 경우

- **장점**
	- `import`시에 간결한 문법을 사용할 수 있다.
		- 예를들어 `import Navbar from './NavBar'와 같이 폴더 이름만 적으면 된다.`
- **단점**
	- <u>여러개의 `index.js` 파일을 동시에 작업하고 있을 때, 파일을 구분하기 어려울 수 있다.</u>
		- 이는 특히 텍스트 에디터나 IDE에서 탭을 사용하여 여러 파일을 동시에 열어 놓을 때 더욱 그렇다. ~~(이거 꽤나 불편했다)~~
	- <u>특정 파일을 검색하거나 찾아보기가 어렵다.</u>
		- 예를 들면, `index.js`로 검색하면 프로젝트의 모든 `index.js`파일이 검색 결과로 나온다.

#### 컴포넌트 이름을 사용 (예: ' Navbar.js')
- **장점**
	- 개방된 각 파일을 쉽게 구분할 수 있다.
		- 이는 특히 여러 파일을 동시에 열어놓을 때 유용합니다.
	- 특정 컴포넌트 파일을 검색하거나 찾기가 훨씬 쉽다.
- **단점**
	- `import` 시에 파일 이름까지 적어야 한다.
		- 예를들어 `import Navbar from './Navbar/Nabvar'`와 같이 작성해야 한다.

#### 따라서
대형 프로젝트나 여러 사람이 함께 작업하는 경우에는 파일을 쉽게 찾고 구분할 수 있도록 <u>컴포넌트 이름을 파일 이름으로 사용하는 것이 일반적</u>이다.
하지만 작은 프로젝트나 개인 프로젝트에서는 "index.js" 방식을 선택하는 것도 좋은 선택일 수 있다.


### 🐑 컴포넌트를 만들 때 `화살표 함수`  vs `일반 함수` 어떤걸 써야할까?

#### `일반함수` 와 `화살표 함수`의 특징
#### 일반 함수 (Function Declartion)
- **장점**
	- 함수 선언은 코드가 실행되기 JavaScript 엔진에 로딩되므로, 함수 선언보다 먼저 함수를 사용할 수 있다.(호이스팅)
	- `this`키워드가 함수의 현재 실행 컨텍스트를 참조한다. 클래스 컴포넌트에서 메서드로 사용되는 경우 `this`는 인스턴스 자체를 참조하게 된다. (하지만 함수형 컴포넌트에서는 일반적으로 `this` 키워드를 사용하지 않는다.)
- **단점**
	- 함수형 컴포넌트에서는 일반적으로 `this` 키워드를 사용하지 않으므로, 이를 활용한 기능을 사용하기 어렵다.

#### 화살표 함수 (Arrow Function)
- **장점**
	- 화살표 함수는 `this` 키워드를 바인딩 하지 않는다. 즉, <u>화살표 함수 내부에서 `this`를 사용하면, 그 `this`는 화살표 함수가 아니라 화살표 함수를 포함하는 (외부의) 코드 컨텍스트를 참조</u>한다. 따라서 화살표 함수는 `this`를 예상한 대로 사용할 수 있도록 도와준다.
	- 간결한 문법을 제공한다.
- **단점**
	- 화살표 함수는 항상 익명 함수이다. 따라서 디버깅 시 함수 이름이 나타나지 않을 수 있어 어려움을 격을 수 있다.
	- 화살표 함수는 호이스팅이 되지 않는다. 때문에 함수를 정의하기 전에 호출하려고 하면 에러가 발생한다.

> 일반적으로 React 컴포넌트를 작성할 대는 화살표 함수를 많이 사용한다. 이는 화살표 함수의 간결한 문법과 `this`바인딩 방식이 함수형 컴포넌트와 잘 맞기 때문이다. 
> 또한 React Hook 같은 기능을 사용할 때 화살표 함수와 잘 호환되는 경우가 많다.


#### 일반함수를 쓰는 경우
1. 메서드를 정의할 때
	- 클래스 컴포넌트에서는 메서드를 정의 할 때 주로 일반함수를 쓴다. 이는 `this` 키워드가 일반함수 내에서 클래스 인스턴스를 참조하기 때문이다
``` js
class MyClass extends React.Component {
    myMethod() {
        console.log(this.props);
    }
    // ...
}

```
하지만 이런경우에 화살표 함수를 사용해서 메서드를 정의하면 `this`를 수동으로 바인딩할 필요가 없다.
``` js
class MyClass extends React.Component {
    myMethod = () => {
        console.log(this.props);
    }
    // ...
}

```

2. JavaScript에서 객체 지향 프로그래밍을 위해 사용하는 생성자 함수는 일반 함수로 선언한다.
```js
function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
}
```

3. generator 함수는 반드시 function 키워드를 사용해야 한다.
4. 호이스팅을 활용해야 할 때 
5. 이름을 갖는 함수가 필요한 경우


